Nearly any modern system for which security is a concern is connected to a network, but many of the protocols used for networking were not designed with security in mind.  The TCP/IP protocol suite, at the heart of most communication on the Internet, is an example of exactly this situation\cite{tcp_problems_back, tcp_attacks_methods}.  TCP, the transimission control protocol, is a packet-based transport level protocol, built on top of the IP layer, which maintains a connection between endpoints.  The establishment of a TCP connection allows for more advanced features, such as dealing with packet loss, duplicates and errors, than are available with connectionless protocols such as UDP \cite{illustrated}. Knowledge of a TCP packet's sequence number is all that is required to \textit{spoof} a connection, so randomization is used as a security mechanism against this\cite{tcp_RFC}. We found that in the face of low-entropy, though, this mechanism fails. 

A TCP connection is defined by the IP address and port number of each end-point, allowing each connection to be represented by a unique 4-tuple of those values.  Connections are opened via a process called the \textit{three-way handshake}.  To begin such a handshake, a SYN packet request is sent with an initial sequence number from a client-side IP address and port to a server listenning on the destination port at the indicated IP address. When a SYN packet is received by a listenning server, a response is sent consisting of its own sequence number, and the originally received client sequence number incremented by one, called an ACK.  Finally, after receiving the server's response, the client sends another packet with its original sequence number, and the server's original sequence number, both incremented by one.  Upon receipt of this third packet, data packets are free to be transferred between client and server with the sequence numbers incremented according to the bytes sent and acknowledgements incremented according to those received.

Each end of the connection only sees what is contained in the packets it receives.  The 4-tuple defining the connection and the appropriate sequence and ACK numbers are all that are required to be accepted at either end, potentially allowing an adversary to send forged packets.  Randomization of the initial sequence numbers for client and server, in addition to an assumption that there is no man-in-the-middle listenning in, is designed to make spoofing connections in this manner difficult.  

In the face of a boot-time entropy hole, the randomness of the initial sequence numbers is very weak. The transport layer is created by the kernel, and as a result, TCP sequence numbers are generated by it as well.  Investigation revealed that a connection's TCP sequence number is a function of the state of the net\_secret source of randomness described in Section 2, the time of its creation, and the 4-tuple defining the connection to which the TCP packet belongs. This was also the case for IP identifiers, but without even a timing component.  Specifically, the 4-tuple is combined with the net\_secret as input to an MD5 hash, whose output is combined with the time information.  As explained in the previous section, the initialization of net\_secret in a low-entropy boot occurs early enough such that its value is the same for each boot. Since the state of the net\_secret is never changed, an adversary with access to the same type of device as the target system only needs to determine the time of packet creation to replicate sequence number generation.

Using the information available to an adversary, we were able to craft an attack which can spoof an arbitrary TCP connection. We first sent a legitimate connection request to the target server to establish a connection.  Given that we already knew the net\_secret state, the 4-tuple, and the MD5 algorithm, we were able to generate a sequence number without any time component.  By subtracting this from the actual sequence number, we were able to deduce the current time component being added.  We then measured the increase in this time component by sending a series of other legitimate data packets to deduce the amount of time being added by the round-trip delay.  Finally, we created a sequence number using the net\_secret and the 4-tuple of the connection we wished to spoof, and added to it the timing component and expected round-trip delay to successfully spoof our desired connection.  This spoofing was successful only for systems for which we could deduce an accurate component for the round-trip delay; systems which used the tsc timesource, for instance, had a timing component that was fine-grained enough to notice differences between the round-trip delay of each packet.  The devices which exhibited the boot-time entropy hole are unlikely to have such high-precision timesources, however, and thus should be susceptible to this attack.  

In addition, we were able to modify our spoofing attack to actually create a probe to uncover systems with the boot-time entropy hole.  We followed the same procedure as in the spoofing attack, but instead of choosing a connection to spoof, we simply made a second legitimate connection with a different 4-tuple so that we could observe the actual sequence number.  Since we already determined the expected sequence number for the second connection in the case of a known net\_secret due to low entropy, if the observed sequence number matched our expected sequence number, we could identify the system as one with low-entropy, and possibly open to other attacks as a consequence.   
