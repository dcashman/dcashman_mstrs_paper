A good deal of previous work has been written about \textit{the} Linux PRNG, which refers to the code which generates user-acccessible random bits via /dev/random and /dev/urandom\cite{linuxPRNG, revisited, viega, pnqs, kmowery, random4}.  This wording is misleading, however, as it ignores other sources of random values inside of the Linux Kernel, including even the random32.c Tausworthe PRNG, closely related to \cite{random3}\cite{tausworthe}.   Though our work is also based primarily on the PRNG associated with /dev/random and /dev/urandom, still referred to henceforth as the Linux PRNG, we also describe here three other entropy pools we encountered during our investigation into the effects of low boot-time entropy on system security.

\subsection{The Linux PRNG}
Due to our desire to further explore the implications of the findings from Heninger et al., our work was done on the same 2.6.32.57 Linux kernel, which was the same version, 2.6.32, used in their work.  The basic structure of the PRNG has remained fairly constant, however, with the main components essentially unchanged in the last few years, and a more detailed explanation from a slightly older version may be found in Gutterman and Pinkas\cite{linuxPRNG}.  The differences between 2.6.32, our test version, and the latest stable release at the time of writing, are primarily limited to additional methods of adding entropy input, which were added in response to the discovery by Heninger et al. of the boot-time entropy hole herein discussed. Thus, the following discussion should be applicable across many different Linux versions. 

The Linux PRNG can be viewed as being comprised of three principle components: a component to maintain and modify the state of the PRNG, a component to add entropy collected by events in the outside system,  and a component to generate output when requested.  The state of the PRNG is maintained as three distinc pools, or stores of bits.  Of the three pools, one is a 512 byte \textit{input} pool, and the other two are 128 byte \textit{output} pools.  The two output pools differ in response to insufficient estimated entropy: the non-blocking pool reads data from the pool in all situations, whereas the blocking pool will block until enough is available.  A read of the system timekeeper provides a number of seconds and nanoseconds with which to initialize the pools.  Entropy events first add bits to the input pool, which may then be passed to the output pools on request, so that they may then serve bits to a requesting application.  The latest kernel version adds these values to the non-blocking pool instead to avoid the low-entropy hole \cite{kmowery}. Each pool has an associated estimate of the amount of entropy contained therein, which is always initialized to zero, and then incremented or decremented as it gathers system randomness and provides output to consumers, respectively.  Each pool also has an associated primitive polynomial, which is used by the mix\_pool\_bytes() function to stir the pool contents whenever its state is changed.  

The portion responsible for adding entropy to the PRNG is essentially the source of randomness for the system.  Computers operate on a fixed set of rules and generate output determinstically from given inputs. The entropy adding component utilizes the timings and values of hard-to-predict, non-determinstic events to introduce this randomness.  In the 2.6.32 kernel, entropy may be collected from disk, input and interrupt timings, though interrupt timings were disabled by default.  As of the latest stable release, interrupt timings had been reenabled and augmented with a fast\_mix() function, and a new function, add\_device\_randomness(), had been added to provide additional unique values to directly combat, again, the boot-time entropy hole at the foundation of this paper. Each entropy event is added to the pools by recording the jiffies count, cycle count and the value associated with the the entropy event itself, such as the key-value on a keyboard press, in a sample and then mixing that 12-16 byte, depending on architecture, value into the input pool by mix\_pool\_bytes().  The amount of estimated bits of entropy added to the pool is dependent on the type of input, and the entropy estimate for the input pool is credited the corresponding amount of bits.  User applications may also mix in data by writing to /dev/urandom or /dev/random, which mix the provided data into the appropriate pool, but do not add to the entropy estimate.

The final component of the Linux PRNG deals with extracting output from the entropy pools, which may be done via three interfaces:  /dev/urandom, /dev/random, and get\_random\_bytes().  /dev/urandom and /dev/random are user-accessible device drivers which read their output from the non-blocking and blocking pools, respectively.  get\_random\_bytes() is the interface used by requests for random data from within the kernel itself, and it too reads from the non-blocking pool. When output is requested of either the blocking or non-blocking pool, a check is first made to see if the entropy count in the current pool is great enough to satisfy the request; if not, a request is made for bytes from the input pool.  The input pool will transfer no more bytes than it has credited entropy, minus a minimum value to keep, to one of the output pools. After the transfer from the input pool, if it was needed, the new entropy count of the output pool is derived and then that number of bytes is extracted.  In the case of the blocking pool, no more than the entropy estimate can be extracted, but the entire requested number may be extracted from the non-blocking pool.  The entropy estimate of the output pool is then decreased accordingly.  The blocking pool repeats this process until it has been able to generate enough bytes as requested by the user. The actual method for extracting data from any of the three pools for consumers involves repeatedly hashing different portions with SHA1 and a 20-byte output buffer, which is mixed back into the pool and folded onto itself to produce a 10-byte output. Bytes must be repeatedly extracted in 10-byte chunks until the request is fulfilled.

\subsection{Tausworthe PRNG}
Another, completely separate PRNG is found in lib/random32.c.  Like the non-blocking pool in the Linux PRNG, it is declared to be unsafe for cryptographic use:
\\
\texttt{
/**                                                                             
       A 32 bit pseudo-random number is generated using a fast                 
       algorithm suitable for simulation. This algorithm is NOT                
       considered safe for cryptographic use.                                  
 */
}  
\\
It too may be divided into the three components mentioned for the Linux PRNG.  The state of this PRNG is maintained by a per-CPU variable called net\_rand\_state, which is just a structure of three unsigned integers.  The system jiffies count is the basis of the first initialization of the PRNG, but as noted in the code, this is extremely weak and likely to be the same across boots.  To combat this, the state may be reseeded after the Linux PRNG is initialized by a call to get\_random\_bytes().   The system entropy events which provide values to the Linux PRNG, described above, do not interact with the Tausworthe PRNG, but entropy may be selectively added by calls to srandom(). srandom() simply XORs the provided unsigned integer with the first one of the PRNG state.  Output from the PRNG is generated by a Tausworthe transformation of each of the three state unsigned integers, which are then XOR'd together.

\subsection{get\_random\_int}
We found a third PRNG, get\_random\_int(), which we encountered during our investigation in the same file as the Linux PRNG. Like the Tauseworthe PRNG, this also relied upon a per-CPU variable and was declared to be unfit for cryptographic use, but more troublingly indicated a misunderstanding of the nature of entropy regarding PRNGs. 
\\
\texttt{
/*                                                                              
  Get a random word for internal kernel use only. Similar to urandom but       
  with the goal of minimal entropy pool depletion. As a result, the random     
  value is not cryptographically secure but for several uses the cost of       
  depleting entropy is too high                                                
 */
}
\\

   The state of this PRNG is simple a pool of 16 bytes, large enough for use with the MD5 hash.  Its state is initialy zeroed memory, but it collects entropy at each request for output by combining the system jiffies count, the process ID and the current cycle count into the first 4 bytes of the pool and then setting the pool to an MD5 hash of the result.  The output generated is the first four bytes of the pool after the hashing.

\subsection{net\_secret}
The final source of randomness we encountered, net\_secret, could not properly be described as a PRNG, but was, nevertheless, used to generate random values.  net\_secret is a 64-byte pool initialized during the boot process by a call to get\_random\_bytes().  Unlike the other sources of randomness, though, its value is never updated, despite a waring in \cite{tcp_RFC} that this should be done occasionally.  Its state is used in combination with an MD5 hash, however, to generate random values for portions of the networking code in combination with the current time and other connection-specific inputs.  
