Another critical part of the Internet which relies on randomization for security is the Domain Name Service (DNS).  DNS is responsible for translating fully qualified domain names, represented as a series of characters separated by periods, such as www.example.com, into numeric IP addresses, such as 1.2.3.4, which are in the form actually used by computers \cite{illustrated}.  Since directly manipulating IP addresses is difficult for humans, DNS is an important component at the heart of the modern use of the Internet, and has correspondingly received attention from malicious users.  A large portion of malicious online activity, such as phishing, click-jacking and cross-site request forgery, is centered around getting users to visit domains which are under a hacker's control\cite{phishing, csrf, clickjack}.  DNS presents another opportunity to do this by associating a popular domain name, like that of a major financial institution, with an attacker-controlled IP address, in a process called DNS poisoning, instead of an authentic one to which it would normally be assigned \cite{DNSPoison}.  Current defenses against DNS poisoning are based on randomization, which is weakened on systems with low boot-time entropy.

DNS is based on a hierarchical system in which a name server is considered an authority on address translations for its own domain(s) and those below it.  Such a name server may know the addresses of other name servers, which in turn know information regarding their sub-domains, and so on.  A query for the address of www.example.com would result in a query of the root server '.' which would give the address of the name server responsible for translations of the .com namespace, which would in turn refer to the nameserver responsible for example.com, and finally to one for www.example.com, which would provide the final IP address translation.  Thus, a look-up of a domain name could take multiple queries.  To alleviate this overhead, translations for the different steps are often cached, preventing the need for repeated look-ups for the same domains.   

DNS poisoning is the process of populating just such a DNS cache with an unauthentic translation of an attacker's choosing.  In its simplest form, this simply required an attacker-controlled DNS resolver to issue a query to a recursive name-server for the domain name to be poisoned and then answer the recursive name-server's subsequent request to name-servers further up the hierarchy before they responded.  To answer the query successfully, the attacker must have matched the DNS query ID, a 16-bit field in the DNS header.  Randomization of this number made DNS poisoning more difficult by reducing the probability of a successful attack to a function of the number of queries that could be made before an authentic response was received and cached, precluding more attacks on that domain name for the cache duration.  The Kaminsky attack, however, got around this by instead sending queries for random domain names with the goal of successfully forging a response for a name-server update\cite{kaminsky}.  The attack could be performed on many domains in parallel and, when properly crafted, would give the attacker complete control of the name-server, and thus enable them to poison the response for an arbitrary domain.  To mitigate this, the source ports of the UDP packets from which the DNS queries were made were then also randomized, to require an extra 16 bits, in addition to the 16 from the DNS ID field, that an attacker would have to know to successfully forge a response.

We desired to determine if these two values, the UDP source port and the DNS query ID, could be more easily determined on systems with the entropy deficiency described earlier.  For the DNS query ID we examined the source code of the resolver provided in version 2.11.1. of glibc, the C standard library on our test machine, with the hope that its randomness was derived from a call to /dev/urandom.  Contrary to our expectations, however, the randomness of the DNS query id field was provided by a combination of resolver's process id and, in the absence of a high precision timer for use with glibc, a get\_time\_of\_day() system call.  Specifically, the seconds returned were left-shifted 8 bits and then XOR'd with the microseconds returned.  Thus, at least for the DNS query ID,the linux PRNG was uninvolved.

The assignment of the UDP source port for requests is set by the Linux Kernel, but a desired source port may be indicated by the user process.  We first measured the value passed by the glibc resolver to confirm that randomization was not being done in user-space, but was rather left to the kernel.  With this confirmed, we traced the randomness associated with the assignment of the UDP source port to a call to net\_random().  Surprisingly, net\_random() is based on a call to a completely separate kernel PRNG located in lib/random32.c, which is based on the Tausworthe linear feedback shift register, described in Section 2.  We found that this PRNG was initially seeded with a self-described weak seed, based on the jiffies count of the system, but was reseeded later after initialization of the normal linux PRNG, with a call to get\_random\_bytes().  This later reseeding was done at only the 6th read from the non-blocking pool, right before the initialization of the net\_secret, as previously discussed in Section 3, and was not observed again on our Slackware system.  Our Ubuntu system, however, reseeded the pool four times during the initial boot.  As a result, the observed initial state of the PRNG in random32.c was identical across all boots in our low-entropy tests for our Slackware system.  

Furthermore, the state of the PRNG only changed when entropy is added via an srandom32() or if a call to random32() stirs it.  In our tests, entropy was only added to the PRNG by four different calls made by ifconfig during initialization, and the entropy seed values were the same for each call across boots.  As a result, we observed the same sequence of UDP source port assignments on every boot.  These findings indicate that an attacker with a properly configured system could be able to determine UDP source port numbers by simply keeping track of the number of UDP packets sent since the low-entropy target system last booted, or observing a series of UDP source port numbers and mapping them to an appropriate place in a pre-configured sequence.  Thus, systems with low boot-time entropy lose the additional protection of randomized UDP source port in DNS transactions and would again be vulnerable to DNS poisoning.


  





