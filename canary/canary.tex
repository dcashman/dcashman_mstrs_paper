Another area in which randomization is used to enhance security, is in the use of stack canaries to defend against perhaps the most iconic of software vulnerabilities: buffer overflows \cite{stackguard, stackguardUse}.  Though widely known since the Morris Worm in 1988, buffer overflow vulnerabilities persist to this day and may present attackers with an opportunity to take complete control of a vulnerable system \cite{buff_overflow_today}. Buffer overflows are of a class of vulnerabilities which rely on the layout of  data in memory, with attacks exploiting the storing of return addresses in stack frames alongside local data \cite{aleph, lowLevSec}. 

Specifically, during program execution, each new function invocation results in the program counter value being changed to the memory location of that function, which requires that the location of the instruction which called the new function be saved to enable execution to return there after the new function finishes. In assembly, this is represented by the function prologue and epilogue, which manage stack frames and change the address stored in the program counter.  Automatic variables, including local arrays, are also stored on the stack and may have their values changed during execution.  A lack of bounds checking when writing to these automatic variables may lead to other addresses being overwritten, as is the case when strcpy() copies characters from a string into an array for which it does not have enough room.  In this case, a buffer overflow has occured, and if enough data was overwritten to also overwrite the stored return address of a calling function, then when the function epilogue restores the program counter using it, the program execution will continue by fetching instructions at the address specificed by its new value.  If an attacker is able to place a memory address of his/her choosing in place of the return address, then he/she may execute code anywhere in the process's address space; this often results in the launch of a root shell specificed by code the attacker placed, or pieced together, elsewhere in memory.

Stack canaries, such as that proposed by Cowan et al in the case of StackGuard, attempt to prevent such overflows by introducing a \textit{canary} in between the automatic variables of a function and the data saved by the function prologue \cite{stackguard}.  The canary consists of a value which is checked in the function epilogue prior to loading the the stored return address into program counter.  If the canary does not still have its original value, then execution is not allowed to continue and the program crashes, rather than directing control do a new, potentially dangerous, region of memory.  As a result, the canary value is randomized to make it difficult for an attacker to replicate it as part of a buffer overflow exploit.  In order to provide an effective defense, the canary value must be different each time the program is run.  On Linux systems, the responsibility for generating the random canary value lies in the kernel, and thus could be affected by poor entropy at boot time.

Our investigation into the security of stack canaries in the presence of low-entropy at boot time began with the observation that one of the very first function calls in start\_kernel() at the very beginning of the linux boot process was a call to boot\_init\_stack\_canary(), which established the stack canary of process 0, running start\_kernel().  This call is made well before the linux PRNG is even initialized, and so would be expected to be deterministic if not relying on other sources of entropy.  Due to reliance on the architecture-specific tsc counter, which would not be present in systems with the boot-time entropy hole in which we're interested, in a special implementation of boot\_init\_stack\_canary() for the x86 machines, we decided to perform our investigation on the ARM architecture instead, which initializes via a call to get\_random\_bytes() from the Linux PRNG.  We used an available Raspberry-Pi B model machine for this purpose.  The special ARM architecture from Broadcom on the machine required us to change to the Raspbian Linux Kernel, of which we chose the most recent 3.6.y.  Changing kernel versions was necessary, we discovered, because the boot\_init\_stack\_canary() code was not implemented for non-x86 architectures in our 2.6.32.57 kernel, anyway.

We recorded this first stack canary from the call of boot\_init\_stack\_canary() and discovered that the initialized value was the same across all boots.  To determine if this early-initialized canary value persisted and ascertain a potential exploit, we wrote a kernel module with a simple buffer overflow vulnerability using get\_usr() without proper bounds-checking. Examination of the stack when calling the function with the vulnerable buffer allowed us to locate the canary and the protected return address. With this information, we successfully wrote an exploit that directed control flow to a different kernel function of our choosing, but unfortunately, we verified that the canary differed from the early-initialized one.  As a result, we were only able to craft a successful exploit when also examing the memory layout directly.  A search through the kernel revealed that a new stack canary value is generated by a call to get\_random\_int(), described in Section 2, upon the forking of every new process when duplicating the process structures.  Thus, since the canary value initialization is completely independent of the Linux PRNG, despite the reliance of the first canary in boot\_init\_stack\_canary() on it, we were unable to defeat the stack security mechanism on a system with low boot-time entropy.  
