Stack canaries, as a low-level security defense, are only capable of thwarting attacks which rely on clobbering return addresses.  Other defenses, such as non-executible stacks and control flow integrity have been established, but are themselves vulnerable to various combinations of other attack vectors, such as function pointers, data contamination, return-to-libc, heap overflows, and more \cite{lowLevSec, freeVuln, format, intOverflow, cfi}.  A completely different defense, Address Space Layout Randomization,  recognizes that these memory-based vulnerabilities are extremely delicate, and may be rendered completely ineffective if the address calculations therein are off \cite{PaX}.  As the name implies, it changes the memory layout such that the program's symbols are mapped to different addresses at each invocation, which is enough to foil the previously mentioned address calculations.  ASLR is now a widely accepted defense mechanism that is still being deployed to new platforms, but suffers when not supplied with sufficient randomness \cite{android_ASLR, ASLP}.  We found that our Linux boot-time entropy hole had no effect upon ASLR, but instead that a different entropy pool was being used to generate its values.

The address space of a process is established when its binary object is loaded from disk by the operating system, and is shared by any process it forks which does not subsequently execute a different program \cite{linkers_loaders}.  We sought to determine if low-entropy in the Linux PRNG could compromise the ASLR of processes loaded early in the boot process.  This required an examination of the ELF loader in the Linux Kernel, which revealed that address spaces for ELF objects are randomized into four principle regions: the text segment, heap, dynamically loaded libraries, and the stack.  

Unfortunately, due to relative address calculations, page table boundaries, and other considerations, ASLR is limited to course-grained randomization, rather than being able to assign each symbol a completely random address\cite{ASLR}.  Thus, while the exact address of a vulnerable buffer may change between program invocations, its location to the stack frame, for example, would remain the same.  In practice, this has meant that ASLR has been vulnerable to brute force attacks due to its inability to use a full 32-bits of entropy for its randomization, but it still presents an effective barrier in situations where this is difficult. 

For our analysis of ASLR in the presence of low-entropy, we installed the Apache web server to allow us to insert and exploit a simple buffer overflow vulnerability similar to the one used in \cite{ASLR}.  The use of Apache was important because it forks child processes to deal with incoming requests, which results in them having the same memory layout as the parent process, a layout established during boot-time.  We then identified the locations in the code of the ELF loader where the text segment, heap and stack base addresses were assigned random values.  The linker-loader and dynamically loaded libraries relied on the kernel do\_mmap() function, which used a random base address determined for the process when do\_execve() is called.  We were surprised to find that none of the ASLR random calls made use of the Linux PRNG, but rather relied on the get\_random\_int randomness source, described in Section 2.  Despite not making use of our boot-time entropy hole, we had hoped that the perceived lack of strength of this randomness source would enable us to effectively circumvent ASLR.

We compared the random values read in the kernel with the output of the memory layout as read by /proc/PID/maps to confirm their role in ASLR.  Once established, we then compared the address space of our Apache process across boots, and repeated for 1000 boots for the init process, which receives its values much earlier.  An interesting side-effect of this was the discovery that the dynamically linked libraries were always in the same positions relative to each other, meaning that do\_mmap() uses only the initial randomization to assign new addresses.  Otherwise, the Apache ASLR generated different memory layouts every time.  This was a side-effect of a gathering of implicit entropy similar to that observed for the non-blocking pool in Section 3.  By the time our Apache process requested the random values for its address space, the get\_random\_int PRNG had produced output over 3000 times, with each read adding its hashed output back into the pool as described in Section 2.  In contrast, the address space of the init process on our modified Slackware system had effectively the same unique address space on every boot, a side effect of getting its values from the first few reads of the get\_random\_int PRNG.  Interestingly, we did not observe any overlap on our Ubuntu machine.  Thus, our attempt to use low boot-time entropy to defeat ASLR failed for our Apache target due to an unexpected, but heavily used, entropy pool.  ASLR protection of earlier processes, such as the init process, however, contains practically no randomness, and may be an issue as early sophisticated processes begin to replace the init process. 
