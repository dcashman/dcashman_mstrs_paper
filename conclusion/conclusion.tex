In this paper, we examine the effect of low boot-time entropy in the Linux PRNG on a selection of randomness-dependent security mechanisms.  Previous work had already shown a significant impact of poor boot-time entropy on system security by measuring an extremely poor distribution of values for cryptographic purposes, an obvious and critical area in need of good randomness.  We show that poor randomness is a problem that extends beyond cyrptography and can lead to security vulnerabilities in other areas.  Specifically, we are able to predict sequence numbers to spoof TCP connections and scan for systems with low boot-time entropy.  We are also able to eliminate the extra layer of security proved by random UDP source port numbers in DNS queries, and to observe a greatly decreased reduced number of possibilities for address space layout randomization for processes which are spawned at the very beginning of the boot process.

We also provide an overview of four different sources of randomness for security critical consumers, only one of which receives entropy inputs from standard hard-to-predict events.  Our interactions with these sources of randomness show that a lack of diversity in requests from PRNGs, a failure to incorporate output back into PRNG state, and a paucity of entropy seeding may all result in vulnerabilities in security mechanisms.  We observe that, in pools which incorporate their output into their state, a heretofore unaccounted source of implicit entropy based on request ordering adds a significant amount of variability later in the boot process, even when no other sources of entropy are present.  

Our observations lead us to believe that the provision of randomness from the kernel should be redesigned according to more modular software engineering and a new threat model.  Our first recommendation is that the four sources of randomness in the Linux kernel be consolidated into only one source which acts as a provider for the entire operating system and user applications.  The division of responsibility between different sources necessarily prevents the maximum use of entropy for all applications.  The ordering of the 3000-plus get\_random\_int() calls alone would introduce a large amount of implicit entropy to the Linux PRNG, which could be increased by incorporating cycle counts every time the pool is mixed, as is done with the get\_random\_int() entropoy pool.  The maintenance of only one source would also developers to focus on making certain that the one source is properly maintained.  This would help avoid simple errors such as the elimination of state reseeding for net\_secret between the Linux 2.4 and 2.6 kernels. 

In addition, the threat model of the Linux PRNG should be updated to reflect the necessity of randomness for kernel provided functions and the bizarre nature of the current entropy accounting process.  The provision of "non-cryptographically strong" values via the kernel get\_random\_bytes() interface ignores the need for good randomness in many kernel functions, including the ones we investigate in this paper.  Moreover, the blocking pool was never used by a /dev/random read during our boot period, even for the cryptographic applications for which it was designed.  Comments indicating that entropy pools are sufficient for non-cryptographic purposes and that entropy should not be depleted reflect a poor understanding of the actual working of the PRNG in the kernel.  To reflect its real-world use and the significance of some of these non-cryptographic security mechanisms, as much entropy should be made available to the non-blocking pool as possible.  Finally, the operation of a strong PRNG should not depend on specific generated entropy estimates.  Given enough initial seeding, and an appropriately strong hash generating the output, it should be infeasible to determine the internal state from the PRNG output, and thus the subsequent values. Consequently, the Linux PRNG should be designed to ensure as much entropy generation as possible at the very beginning of the boot process, rather than providing poor random values for almost all consumers, while waiting for entropy accounting in other pools to reach a threshold.  A source of \textit{truly random} bits, as /dev/random is meant to be, should be given a lower priority given its infrequent use.

