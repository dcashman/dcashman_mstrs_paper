We first tried, with partial success, to see if we could accurately replicate the low-entropy output found in Heninger et al, and in the process of doing so discovered a source of implicit entropy in the non-blocking pool.  To do this, we first attempted to replicate their environment.  We used Linux version 2.6.32.57 and compiled it on both a VMware virtual machine running Ubuntu desktop 12.04, with 1GB of RAM and 1 processor, and an hp pavillion running Ubuntu Server 10.04, but due to mechanical failure, replaced our pavillion with a Lenovo Thinkpad R61 running Slackware 13.0 instead. We modified the Linux PRNG so that it was zeroed at initialization to simulate a cold boot, initialized the timesource in the kernel to zero to simulate the lack of a working clock, and limited the machine to using only one processor to simulate a simple headless embedded device, all in accordance with the findings of Heninger et al.  We were unable to reproduce their exact results, but discovered a source of what we define as \textit{implicit entropy}, which is simply a source of entropy unaccounted by the PRNG. 

Once set-up, we ran 1000 boots under these conditions and recorded 4 and 128 bytes of output from /dev/urandom.  Unfortunately, we did not find any repeated readings, in contrast to the only 27 values found by Heninger et al. To account for this disparity, we recorded a summary of the state of the non-blocking pool in the Linux PRNG each time its state was modified.  The difference between the state of the non-blocking pool compared to all other boots is shown in figure 1, with the state between boots diverging at different clusters of reads.  We found that the estimated entropy of the non-blocking pool was zero for the entire duration of our boot until reading from /dev/urandom, and that the estimated entropy for the input pool reached, on average 138 bits on our Ubuntu system and 155 on our, much slower, Slackware one.  At the point where the state of non-blocking pool diverged between boots, though, the input pool also had zero entropy, meaning that no gathered entropy was being transferred to the non-blocking pool.  The only source of change for the pool's contents was the hashing and mixing triggered on each output request. 

Therefore, the difference in values between boots could only by explained by the order in which output requests were made, which acts as a source of implicit entropy gathering, similar to the race conditions discussed by Heninger et al \cite{pnqs}.  Due to the folding back into the pool of hashed output, a change between boots in the number of previous requests for any new request will lead to it obtaining a different output value.  The value read may even be different if the number of previous requests is constant, however, if the ordering of the previous requests is different.  This is because the pool stirring for each read is a function of the bytes requested, and so the pool state after a read of \textit{x} bytes followed by a read of \textit{y} bytes will not be the same as the pool state after a read of \textit{y} followed by \textit{x}, provided \textit{x} and \textit{y} are different values. If the reads are for the same number of bytes, though, then the state of the pool will be the same after any ordering. 

We found that the vast majority of requests for data from the non-blocking pool, 494 out of 552 reads on our Slackware system and 826 out of 854 on our Ubuntu system, were 16-byte get\_random\_bytes() calls, meaning that the ordering of the remaining calls was responsible for the variation we encountered.   What's more, the diversity of non-16-byte requests was fairly low; 31 of the 58 calls responsible on our slackware system, 7 of 28 on Ubuntu, for the implicit entropy we observed came from the same origin.  Disabling just that source resulted in the non-blocking pool state diverging between boots later than with it included.  This is shown in figure 1, which shows the non-blocking pool state on our Ubuntu machine (our Slackware machine was slow enough that almost all divergence happened after only the 39th read).  For perspective, our read of /dev/urandom occured always occured after the 543rd read and before the 547th read for our Slackware system, and after the 878th and before the 921st on Ubuntu.  Likewise, the seeding of the Tausworthe and net\_secret sources of randomness occured at approximately the 6th and 7th requests, respectively.  These requests were before any divergence across boots, a fact of which we made use in sections 4 and 7.  Thus, we were able to replicate deterministic results under the given assumptions, but to a lesser-degree than found by Heninger et al. A system configured without a large subset of these sources of implicit entropy generating non-16-byte requests, however, would be without the implicit entropy found therein, and should lead to a smaller range of possible output values while entropy from normal sources is being gathered.



